#!/bin/sh
#==============================================================================
#       _                 _
#      | |               | |
#    __| |_ __ ___    ___| |__
#   / _` | '_ ` _ \  / __| '_ \
#  | (_| | | | | | |_\__ \ | | |
#   \__,_|_| |_| |_(_)___/_| |_|
#
#==============================================================================

#==============================================================================
# SANE ENVIRONMENT
#==============================================================================

set -e  # Exit on error.
set -u  # Unbound variable safe guard.

#==============================================================================
# INITIAL PATH CHANGE
#==============================================================================

DM__GLOBAL__RUNTIME__PATH="$(dirname "$(readlink -f "$0")")"
cd "${DM__GLOBAL__RUNTIME__PATH}"

#==============================================================================
# LOAD EXTERNAL LIBRARIES
#==============================================================================

. ./dm.lib.sh

#==============================================================================
# GLOBAL SCRIPT BASED VARIABLES
#==============================================================================

DM__GLOBAL__RUNTIME__VERSION=$(cat "${DM__GLOBAL__RUNTIME__PATH}/../VERSION")
DM__GLOBAL__CLI__PROMPT=" ${BOLD}dm${RESET} # "
DM__GLOBAL__CLI__EXIT_CONDITION="0"

#==============================================================================
# PARAMETER PARSING
#==============================================================================

# Relative path to the modules directory relative to this file. It is
# calculated during installation by the install script.
DM__GLOBAL__RUNTIME__MODULES_ROOT="$1"

# Temporary parameters file path that is generated by the Makefile target
# before calling this script by writing the user editable parameters to the
# temporary parameter file in a specific order. It is important to keep this
# order in sync between the Makefile and this script. This script has to delete
# the temporary file after getting all parameters from it.
DM__PARAMETER_FILE_PATH="$2"

# Flag that is passed from the Makedile to signal that global debugging is
# enabled. If the value is not `0`, then the debug messages will be printed to
# the standard error output of the dm process.
DM__GLOBAL__RUNTIME__DEBUG_ENABLED="$3"


DM__GLOBAL__WARNING__MODULE_DOC_WRAPPING="Consider reformatting the module's documentation to not to exceed the predefined character line length and prevent automatic line wrapping. You can turn off this warning by modifying your main Makefile in the config section [DM_CONFIG__WARNING__WRAPPED_DOCS]."


#==============================================================================
# PARAMETER FILE PARSING
#==============================================================================

# Based on the given temporary parameter file generated by the Makefile before
# calling this script, the used editable parameters has to be read. This is a
# relative effitient way to pass parameters without the fear of abusing the
# arguments list of this script..

# PARAMETER 1
#------------------------------------------------------------------------------
# Global text wrapping limit. Every function that prints to the console has to
# respect this limit.
DM__GLOBAL__CONFIG__CLI__TEXT_WRAP_LIMIT="$( \
  dm_lib__config__load_parameter "1" "80" "$DM__PARAMETER_FILE_PATH" \
)"

# PARAMETER 2
#------------------------------------------------------------------------------
# Default command indentation amount for functions that prints out left aligned
# text.
DM__GLOBAL__CONFIG__CLI__INDENT_AMOUNT="$( \
  dm_lib__config__load_parameter "2" "4" "$DM__PARAMETER_FILE_PATH" \
)"
# Cached variable for the default indentation.
DM__GLOBAL__CONFIG__CLI__INDENT="$( \
  printf "%${DM__GLOBAL__CONFIG__CLI__INDENT_AMOUNT}s" "" \
)"

# PARAMETER 3
#------------------------------------------------------------------------------
# Warning supressor flag that controls the appearance of the waring issued if a
# module documentation line exceeds the global wrapping limit. Setting this
# variable to 0 will disable the warning.
DM__GLOBAL__CONFIG__CLI__WARNING__WRAPPED_DOCS="$( \
  dm_lib__config__load_parameter "3" "1" "$DM__PARAMETER_FILE_PATH" \
)"

# PARAMETER 4
#------------------------------------------------------------------------------
# Exit command hotkeys.
DM__GLOBAL__CONFIG__CLI__COMMAND_HOTKEYS__EXIT="$( \
  dm_lib__config__load_parameter "4" "q|quit|exit" "$DM__PARAMETER_FILE_PATH" \
)"

# PARAMETER 5
#------------------------------------------------------------------------------
# Help command hotkeys.
DM__GLOBAL__CONFIG__CLI__COMMAND_HOTKEYS__HELP="$( \
  dm_lib__config__load_parameter "5" "?|help" "$DM__PARAMETER_FILE_PATH" \
)"

# PARAMETER 6
#------------------------------------------------------------------------------
# Version command hotkeys.
DM__GLOBAL__CONFIG__CLI__COMMAND_HOTKEYS__VERSION="$( \
  dm_lib__config__load_parameter "6" "version" "$DM__PARAMETER_FILE_PATH" \
)"

# PARAMETER 7
#------------------------------------------------------------------------------
# Variables command hotkeys.
DM__GLOBAL__CONFIG__CLI__COMMAND_HOTKEYS__VARIABLES="$( \
  dm_lib__config__load_parameter "7" "v|variables" "$DM__PARAMETER_FILE_PATH" \
)"

# PARAMETER 8
#------------------------------------------------------------------------------
# Hooks command hotkeys.
DM__GLOBAL__CONFIG__CLI__COMMAND_HOTKEYS__HOOKS="$( \
  dm_lib__config__load_parameter "8" "h|hooks" "$DM__PARAMETER_FILE_PATH" \
)"

# PARAMETER 9
#------------------------------------------------------------------------------
# Signals command hotkeys.
DM__GLOBAL__CONFIG__CLI__COMMAND_HOTKEYS__SIGNALS="$( \
  dm_lib__config__load_parameter "9" "s|signals" "$DM__PARAMETER_FILE_PATH" \
)"

# PARAMETER 10
#------------------------------------------------------------------------------
# Modules command hotkeys.
DM__GLOBAL__CONFIG__CLI__COMMAND_HOTKEYS__MODULES="$( \
  dm_lib__config__load_parameter "10" "m|modules" "$DM__PARAMETER_FILE_PATH" \
)"

# PARAMETER 11
#------------------------------------------------------------------------------
# Deploy command hotkeys.
DM__GLOBAL__CONFIG__CLI__COMMAND_HOTKEYS__DEPLOY="$( \
  dm_lib__config__load_parameter "11" "d|deploy" "$DM__PARAMETER_FILE_PATH" \
)"

# Removing the parameters passing file right after the parsing.
rm "$DM__PARAMETER_FILE_PATH"


#==============================================================================
#    _____ _      _____   _       _                        _
#   / ____| |    |_   _| (_)     | |                      | |
#  | |    | |      | |    _ _ __ | |_ ___ _ __ _ __   __ _| |___
#  | |    | |      | |   | | '_ \| __/ _ \ '__| '_ \ / _` | / __|
#  | |____| |____ _| |_  | | | | | ||  __/ |  | | | | (_| | \__ \
#   \_____|______|_____| |_|_| |_|\__\___|_|  |_| |_|\__,_|_|___/
#
#==============================================================================

#==============================================================================
# UTILITY FUNCTIONS
#==============================================================================

#==============================================================================
# Helper function that indents every line sent to its standard input with a
# predefined amount.
#==============================================================================
# INPUT
#==============================================================================
# Global variables
# - DM__GLOBAL__CONFIG__CLI__INDENT
#
# Arguments
# - None
#
# StdIn
# - Lines that needs to be indented.
#
#==============================================================================
# OUTPUT
#==============================================================================
# Output variables
# - None
#
# StdOut
# - Indented lines.
#
# StdErr
# - Error that occured during operation.
#
# Status
# -  0 : ok
# - !0 : error
#==============================================================================
_dm_cli__utils__indent() {
  # Indents the given message to a common level.
  cat - | sed "s/^/${DM__GLOBAL__CONFIG__CLI__INDENT}/"
}

#==============================================================================
# Display function that takes a multiline text and a header name alongside with
# formatting information and prints out the header followed by the multiline
# text. It also respects the global wrapping limit, and breaks up the
# overhanging lines. This function can be used to display dynamic summary pages
# in a clear, formatted way. The header will be printed only in the first line.
#
# Internally it uses two named pipes that gets removed right after the usage.
# On error these named pipes could be left on your disk, but after a clean run,
# they will be cleaned up.
#==============================================================================
# INPUT
#==============================================================================
# Global variables
# - DM__GLOBAL__CONFIG__CLI__TEXT_WRAP_LIMIT
#
# Arguments
# - 1: Header padding size. This parameter is used to calculate the wrapping
#      point for the multiline text. This size will be subtracted from the
#      global wrapping limit.
# - 2: Format for the whole line with position based placeholders for the
#      header and the data rows. This format will be directly passed to the
#      `printf` command so you need to respect its formatting rules.
# - 3: Header string that will be printed in the first line only.
# - 4: Multiline data lines. This lines will be wrapped to the global wrapping
#      limit. Leading and trailing whitespace will be kept.
# - 5: Optional coloring escape sequence to be able to change the coloring of
#      the first word of every lines. This can be useful if you want to print out
#      named vales for a common key. The key gets empathized.
#
# StdIn
# - Lines that needs to be indented.
#
#==============================================================================
# OUTPUT
#==============================================================================
# Output variables
# - None
#
# StdOut
# - Indented lines.
#
# StdErr
# - Error that occured during operation.
#
# Status
# -  0 : ok
# - !0 : error
#==============================================================================
_dm_cli__utils__header_multiline() {
  header_padding="$1"
  format="$2"
  header="$3"
  lines="$4"

  # Optional fifth coloring parameter for the leading words for every line.
  if [ "$#" = 5 ]
  then
    highlight_color="$5"
  else
    highlight_color=""
  fi

  # This function fill be mostly used to display text sections where the
  # section headers are usually a right aligned words with a fix width. This
  # width is passed to the function to be able to take into account for the
  # global width calculation. Without this the global text wrap limit will be
  # probably passed by this function.
  wrap_limit="$((DM__GLOBAL__CONFIG__CLI__TEXT_WRAP_LIMIT - header_padding))"

  # With named pipes we can feed the while loops to read the lines while being
  # able to access the outer context. The usual piped approach won't work as
  # the pipe operator creates a subshell. Beside this solution we could have
  # also used temporary files but this is a more elegant approach. Reaching the
  # outside context is necessary as the function relies on flags that stored
  # outside the loops.
  rm -f outer_temp_pipe
  mkfifo outer_temp_pipe
  echo "$lines" > outer_temp_pipe &

  header_line_passed="0"

  # The outer while loop is responsible for looping through the input lines
  # passed to the function. The internal while loop is responsible for wrapping
  # the given lines to a predefined maximum width. By doing this the internal
  # loop has to pay attention to the header printout as it needs to be printed
  # only once.

  # The outer named pipe will be fed to the loop at the end.
  while IFS= read -r line
  do
    rm -f inner_temp_pipe
    mkfifo inner_temp_pipe
    echo "$line" | fmt --split-only --width="$wrap_limit" > inner_temp_pipe &

    first_wrapped_line_has_passed="0"
    # Inner named pipe will be fed to the loop at the end.
    while IFS= read -r wrapped_line
    do

      # Highlighting the first word of the first wrapped line. If there is a
      # 5th formatting parameter given, the it will be used here. We assume
      # that there are only one space between the first and second word.
      if [ "$first_wrapped_line_has_passed" = "0" ]
      then
        first="${wrapped_line%% *}"  # getting the first element from the list
        rest="${wrapped_line#* }"  # getting all items but the first
        wrapped_line="${highlight_color}${first}${RESET} ${rest}"
        first_wrapped_line_has_passed="1"
      fi

      # The header should be printed only in the first line being it wrapped or
      # not. Setting this global variable here in the wrapped line level will
      # ensure that the header will be printed once.
      if [ "$header_line_passed" = "0" ]
      then
        target_header="$header"
        header_line_passed="1"
      else
        target_header=""
      fi

      # Te point here is to be able to receive dynamic formats so we need to
      # allow the dynamic templated format here.
      # shellcheck disable=SC2059
      printf "$format" "$target_header" "$wrapped_line"

    done < inner_temp_pipe
    rm -f inner_temp_pipe

  done < outer_temp_pipe
  rm -f outer_temp_pipe
}


#==============================================================================
# COMMAND REGISTERING
#==============================================================================
# The dm cli has a completely dynamic command registering system, that
# decouples it completely from the interpreter system. New commands can be
# registered easily alongside with the documentation. The registering system
# offers an interrogation interface for the registered commands.
#
# Each registered command should be implemented in a callable function. This
# function name gets registered and returned upon command search.

# Global variable to store the registered commands.
DM_CLI__RUNTIME__REGISTERED_COMMANDS=""

# Global variable to store the short documentation for the commands.
DM_CLI__RUNTIME__REGISTERED_COMMAND_DOCS=""

# Global variable to store the default command.
DM_CLI__RUNTIME__DEFAULT_COMMAND=""

#==============================================================================
# Function to register the function name for a command with a hotkey list and a
# short documentation for the command that will be displayed in the help menu.
#
# Each command keyword gets written to a separate line followed by the
# registered command's function name providing an easily searchable list for
# later usage.
#
# Short documentation is handled similarly to the function names. For ech
# keyword the full short documentation is written into a separate line.
#==============================================================================
# INPUT
#==============================================================================
# Global variables
# - DM_CLI__RUNTIME__REGISTERED_COMMANDS
# - DM_CLI__RUNTIME__REGISTERED_COMMAND_DOCS
#
# Arguments
# - 1: Pipe character separated list of hotkeys that should trigger the command
#      on search.
# - 2: Function name for the given command.
# - 3: Short documentation for the given command.
#
# StdIn
# - None
#
#==============================================================================
# OUTPUT
#==============================================================================
# Output variables
# - None
#
# StdOut
# - None
#
# StdErr
# - Error that occured during operation.
#
# Status
# -  0 : ok
# - !0 : error
#==============================================================================
dm_cli__register_command() {
  hotkeys="$1"
  _command="$2"
  doc="$3"

  # Hotkeys can be separated by a pipe character.
  for hotkey in $(echo "$hotkeys" | sed 's/|/ /g')
  do
    dm_lib__debug "dm_cli__register_command" \
      "processing hotkey '${hotkey}'"
    DM_CLI__RUNTIME__REGISTERED_COMMANDS="$( \
      echo "${DM_CLI__RUNTIME__REGISTERED_COMMANDS}"; \
      echo "${hotkey} ${_command}" \
    )"
  done

  DM_CLI__RUNTIME__REGISTERED_COMMAND_DOCS="$( \
    echo "${DM_CLI__RUNTIME__REGISTERED_COMMAND_DOCS}"; \
    echo "${hotkeys} ${doc}" \
  )"

  dm_lib__debug "dm_cli__register_command" \
    "command '${_command}' registered for hotkey '${hotkeys}'"
}

#==============================================================================
# Function to register the function name for the default command.
#==============================================================================
# INPUT
#==============================================================================
# Global variables
# - DM_CLI__RUNTIME__DEFAULT_COMMAND
#
# Arguments
# - 1: Function name for the default command.
#
# StdIn
# - None
#
#==============================================================================
# OUTPUT
#==============================================================================
# Output variables
# - None
#
# StdOut
# - None
#
# StdErr
# - Error that occured during operation.
#
# Status
# -  0 : ok
# - !0 : error
#==============================================================================
dm_cli__register_default_command() {
  _command="$1"
  DM_CLI__RUNTIME__DEFAULT_COMMAND="$_command"
  dm_lib__debug "dm_cli__register_default_command" \
    "command '${_command}' registered as the default command"
}

#==============================================================================
# Function to search and return the registered function name for the given
# command. If the given command is not found, the registered default command
# function gets returned.
#==============================================================================
# INPUT
#==============================================================================
# Global variables
# - DM_CLI__RUNTIME__DEFAULT_COMMAND
# - DM_CLI__RUNTIME__REGISTERED_COMMANDS
#
# Arguments
# - 1: Raw command query string. Based on this parameter the function tries to
#      find the command and returns the registered function name.
#
# StdIn
# - None
#
#==============================================================================
# OUTPUT
#==============================================================================
# Output variables
# - None
#
# StdOut
# - Registered function name that is matched for the given command query string.
#
# StdErr
# - Error that occured during operation.
#
# Status
# -  0 : ok
# - !0 : error
#==============================================================================
_dm_cli__get_command() {
  raw_command="$1"
  dm_lib__debug "_dm_cli__get_command" \
    "processing raw command: '${raw_command}'"

  hotkey=$(echo "$raw_command" | _dm_lib__utils__trim_list 1)
  word_count=$(echo "$raw_command" | wc -w)
  if [ "$word_count" -gt 1 ]
  then
    params=$(echo "$raw_command" | _dm_lib__utils__trim_list 2-)
    dm_lib__debug "_dm_cli__get_command" \
      "received additional paramters: '${params}'"
  else
    params=""
    dm_lib__debug "_dm_cli__get_command" \
      "no additional parameters received"
  fi

  dm_lib__debug "_dm_cli__get_command" \
    "matching registered command for hotkey: '${hotkey}'"
  result=$(echo "$DM_CLI__RUNTIME__REGISTERED_COMMANDS" | grep -E "^${hotkey}\s" || true)
  if [ -n "$result" ]
  then
    _command=$(echo "$result" | _dm_lib__utils__trim_list 2)
    dm_lib__debug "_dm_cli__get_command" \
      "command matched: '${_command}'"
    _command="$_command $params"
  else
    dm_lib__debug "_dm_cli__get_command" \
      "no match for hotkey, using default command: '${DM_CLI__RUNTIME__DEFAULT_COMMAND}'"
    _command="$DM_CLI__RUNTIME__DEFAULT_COMMAND"
  fi
  echo "$_command" | _dm_lib__utils__remove_surrounding_whitespace
}


#==============================================================================
#    _____                                          _
#   / ____|                                        | |
#  | |     ___  _ __ ___  _ __ ___   __ _ _ __   __| |___
#  | |    / _ \| '_ ` _ \| '_ ` _ \ / _` | '_ \ / _` / __|
#  | |___| (_) | | | | | | | | | | | (_| | | | | (_| \__ \
#   \_____\___/|_| |_| |_|_| |_| |_|\__,_|_| |_|\__,_|___/
#
#==============================================================================


#==============================================================================
# COMMAND: EXIT
#==============================================================================

dm_cli__register_command \
  "$DM__GLOBAL__CONFIG__CLI__COMMAND_HOTKEYS__EXIT" \
  "dm_cli__interpreter_quit" \
  "Exits the dotmodules interpreter."
dm_cli__interpreter_quit() {
  dm_lib__debug "dm_cli__interpreter_quit" \
    "interpreter quit called, setting exit condition.."
  DM__GLOBAL__CLI__EXIT_CONDITION="1"
}


#==============================================================================
# COMMAND: HELP
#==============================================================================

dm_cli__register_command \
  "$DM__GLOBAL__CONFIG__CLI__COMMAND_HOTKEYS__HELP" \
  "dm_cli__help" \
  "Prints out this help message. This is the default command."
dm_cli__register_default_command "dm_cli__help"
dm_cli__help() {
  echo ""
  echo "$DM_CLI__RUNTIME__REGISTERED_COMMAND_DOCS" | sed '/^[[:space:]]*$/d' | while read -r line
  do
    hotkeys="${line%% *}"  # getting the first element from the list
    doc="${line#* }"  # getting all items but the first

    header_padding="14"
    format="${BOLD}${CYAN}%${header_padding}s${RESET} %s\n"

    _dm_cli__utils__header_multiline \
      "$header_padding" \
      "$format" \
      "$hotkeys" \
      "$doc"
  done
  echo ""
}


#==============================================================================
# COMMAND: VERSION
#==============================================================================

dm_cli__register_command \
  "$DM__GLOBAL__CONFIG__CLI__COMMAND_HOTKEYS__VERSION" \
  "dm_cli__version" \
  "Prints out the dotmodules version."
dm_cli__version() {
  echo ""
  echo "${BOLD}dotmodules${RESET} ${DIM}v${DM__GLOBAL__RUNTIME__VERSION}${RESET}" | _dm_cli__utils__indent
  echo ""
}


#==============================================================================
# COMMAND: VARIABLES
#==============================================================================

dm_cli__register_command \
  "$DM__GLOBAL__CONFIG__CLI__COMMAND_HOTKEYS__VARIABLES" \
  "dm_cli__list_variables" \
  "Prints out all collected variables."
dm_cli__list_variables() {
  dm_lib__debug "dm_cli__list_variables" \
    "displaying the content of the full variable cache.."
  echo ""

  header_padding="$(_dm_cli__list_variables__calculate_padding)"

  while read -r line
  do
    variable_name="$(echo "$line" | _dm_lib__utils__trim_list 1)"
    values="$(echo "$line" | _dm_lib__utils__trim_list 2-)"

    format="${BOLD}%${header_padding}s${RESET} %s\n"

    _dm_cli__utils__header_multiline \
      "$header_padding" \
      "$format" \
      "$variable_name" \
      "$values"
  done < "$DM__GLOBAL__CONFIG__CACHE__VARIABLES_FILE"

  echo ""
}

_dm_cli__list_variables__calculate_padding() {
  max_varibale_name_length="$( \
    cut --delimiter=' ' --fields='1' "$DM__GLOBAL__CONFIG__CACHE__VARIABLES_FILE" | \
    wc --max-line-length \
  )"
  dm_lib__debug "_dm_cli__list_variables__calculate_padding" \
    "max variable name length: '${max_varibale_name_length}'"

  padding="$(( max_varibale_name_length + DM__GLOBAL__CONFIG__CLI__INDENT_AMOUNT ))"

  dm_lib__debug "_dm_cli__list_variables__calculate_padding" \
    "calculated variable padding: '${padding}'"

  echo "$padding"
}


#==============================================================================
# COMMAND: HOOKS
#==============================================================================

dm_cli__register_command \
  "$DM__GLOBAL__CONFIG__CLI__COMMAND_HOTKEYS__HOOKS" \
  "dm_cli__list_hooks" \
  "Prints out all registered hooks sorted by priority."
dm_cli__list_hooks() {
  dm_lib__debug "dm_cli__list_hooks" \
    "gathering registered hooks.."
  echo ""

  echo "Das ist hooks!" | _dm_cli__utils__indent

  echo ""
}


#==============================================================================
# COMMAND: SIGNALS
#==============================================================================

dm_cli__register_command \
  "$DM__GLOBAL__CONFIG__CLI__COMMAND_HOTKEYS__SIGNALS" \
  "dm_cli__list_signals" \
  "Prints out all registered hooks sorted by priority."
dm_cli__list_signals() {
  dm_lib__debug "dm_cli__list_signals" \
    "gathering registered signals.."
  echo ""

  echo "Das ist signals!" | _dm_cli__utils__indent

  echo ""
}


#==============================================================================
# COMMAND: MODULES
#==============================================================================

dm_cli__register_command \
  "$DM__GLOBAL__CONFIG__CLI__COMMAND_HOTKEYS__MODULES" \
  "dm_cli__modules" \
  "Lists all detected modules by default. In the list there is an assigned index for each module that can be used as a parameter to show the given module details."
dm_cli__modules() {
  echo ""
  if [ "$#" = "0" ]
  then
    _dm_cli__list_modules | column --table --separator ":" | _dm_cli__utils__indent
  else
    index="$1"
    _dm_cli__show_module "$index"
  fi
  echo ""
}

_dm_cli__list_modules() {
  index=1
  modules=$(dm_lib__modules__list)
  for module in $modules
  do
    name="$(dm_lib__config__get_name "$module")"
    version="$(dm_lib__config__get_version "$module")"
    status="deployed"

    name="${BOLD}${name}${RESET}"
    version="${version}"
    status="${BOLD}${GREEN}${status}${RESET}"
    path="$(readlink -f "${module}")"

    echo "[${index}]:${name}:${version}:${status}:${module}"
    index=$((index + 1))
  done
}

_dm_cli__show_module__prepare_links() {
  module="$1"
  dm_lib__debug "_dm_cli__show_module__prepare_links" \
    "preparing link display for module '${module}'"

  dm_lib__config__get_links "$module" | while read -r link_string
  do
    dm_lib__debug "_dm_cli__show_module__prepare_links" \
      "processing link_string '${link_string}'"

    processed_link="$(_dm_lib__links__preprocess_raw_link_string "$module" "$link_string")"
    target_path="${processed_link%% *}"  # getting the first element from the list
    link_name="${processed_link#* }"  # getting all items but the first

    dm_lib__debug "_dm_cli__show_module__prepare_links" \
      "target_path '${target_path}'"
    dm_lib__debug "_dm_cli__show_module__prepare_links" \
      "link_name '${link_name}'"

    result="$(_dm_lib__links__check_link "$target_path" "$link_name")"

    if [ "$result" = "$DM__GLOBAL__CONFIG__LINK__NOT_EXISTS" ]
    then
      prefix="[${BOLD}${RED}link${RESET}|${BOLD}${RED}target${RESET}]"
    elif [ "$result" = "$DM__GLOBAL__CONFIG__LINK__EXISTS_BUT_TARGET_MISMATCH" ]
    then
      prefix="[${BOLD}${GREEN}link${RESET}|${BOLD}${RED}target${RESET}]"
    elif [ "$result" = "$DM__GLOBAL__CONFIG__LINK__EXISTS_WITH_TARGET" ]
    then
      prefix="[${BOLD}${GREEN}link${RESET}|${BOLD}${GREEN}target${RESET}]"
    else
      :
    fi
    echo "${prefix} ${link_string}"
  done
}

_dm_cli__show_module() {
  selected_index="$1"

  if module="$(dm_lib__modules__module_by_index "$selected_index")"
  then
    :
  else
    module_count="$(dm_lib__modules__list | wc -l)"
    echo "${RED}Invalid module index! Should be in range 1-${module_count}.${RESET}" | \
      _dm_cli__utils__indent
    return
  fi

  dm_lib__debug "_dm_cli__show_module" "module selected: '${module}'"

  name="$(dm_lib__config__get_name "$module")"
  version="$(dm_lib__config__get_version "$module")"
  status="deployed"
  docs="$(dm_lib__config__get_docs "$module")"
  variables="$(dm_lib__config__get_variables "$module" | sort)"
  hooks="$(dm_lib__config__get_hooks "$module")"

  links="$(_dm_cli__show_module__prepare_links "$module")"

  name="${BOLD}${name}${RESET}"
  version="${version}"
  status="${BOLD}${GREEN}${status}${RESET}"
  path="$(readlink -f "${module}")"

  header_padding="10"
  format="${DIM}%${header_padding}s${RESET} %s\n"

  _dm_cli__utils__header_multiline "$header_padding" "$format" "Name" "$name"
  _dm_cli__utils__header_multiline "$header_padding" "$format" "Version" "$version"
  echo ""
  _dm_cli__utils__header_multiline "$header_padding" "$format" "Status" "$status"
  echo ""
  _dm_cli__utils__header_multiline "$header_padding" "$format" "Docs" "$docs"
  echo ""
  _dm_cli__utils__header_multiline "$header_padding" "$format" "Path" "$path"
  echo ""
  _dm_cli__utils__header_multiline "$header_padding" "$format" "Variables" "$variables" "${BOLD}"
  echo ""
  _dm_cli__utils__header_multiline "$header_padding" "$format" "Links" "$links"
  echo ""
  _dm_cli__utils__header_multiline "$header_padding" "$format" "Hooks" "$hooks" "${BOLD}"

  if [ "$DM__GLOBAL__CONFIG__CLI__WARNING__WRAPPED_DOCS" -eq "0" ]
  then
    dm_lib__debug "_dm_cli__show_module" "ignoring warning about line wrapping"
    return
  fi

  wrap_limit="$((DM__GLOBAL__CONFIG__CLI__TEXT_WRAP_LIMIT - header_padding))"

  if [ "$(echo "$docs" | wc --max-line-length)" -gt "$wrap_limit" ]
  then
    echo ""
    format="${DIM}${YELLOW}%${header_padding}s${RESET} ${DIM}%s${RESET}\n"

    _dm_cli__utils__header_multiline \
      "$header_padding" \
      "$format" \
      "Warning" \
      "$DM__GLOBAL__WARNING__MODULE_DOC_WRAPPING"
  fi
}


#==============================================================================
# COMMAND: DEPLOY
#==============================================================================

dm_cli__register_command \
  "$DM__GLOBAL__CONFIG__CLI__COMMAND_HOTKEYS__DEPLOY" \
  "dm_cli__deploy" \
  "Deploys all modules. If an index is provided as a parameter, then only the given modules gets deployed."
dm_cli__deploy() {
  echo ""
  if [ "$#" = "0" ]
  then
    dm_lib__debug "dm_cli__deploy" "deploying all modules"
    _dm_cli__deploy_all
  else
    index="$1"
    dm_lib__debug "dm_cli__deploy" "deploying module for index '$index'"
    _dm_cli__deploy_single "$index"
  fi
  echo ""
}

_dm_cli__deploy_all() {
  :
}

_dm_cli__deploy_single() {
  selected_index="$1"
  if module="$(dm_lib__modules__module_by_index "$selected_index")"
  then
    :
  else
    module_count="$(dm_lib__modules__list | wc -l)"
    echo "${RED}Invalid module index! Should be in the range of [1-${module_count}].${RESET}" | _dm_cli__utils__indent
    return
  fi

  dm_lib__deploy__deploy_module "$module" | _dm_cli__utils__indent
}


#==============================================================================
#   _____       _                           _
#  |_   _|     | |                         | |
#    | |  _ __ | |_ ___ _ __ _ __  _ __ ___| |_ ___ _ __
#    | | | '_ \| __/ _ \ '__| '_ \| '__/ _ \ __/ _ \ '__|
#   _| |_| | | | ||  __/ |  | |_) | | |  __/ ||  __/ |
#  |_____|_| |_|\__\___|_|  | .__/|_|  \___|\__\___|_|
#                           | |
#===========================|_|================================================

#==============================================================================
# Interpreter implementation that waits for the user's input and tries to find
# the commands for the input.
#==============================================================================
# INPUT
#==============================================================================
# Global variables
# - DM__GLOBAL__CLI__EXIT_CONDITION
# - DM__GLOBAL__CLI__PROMPT
#
# Arguments
# - None
#
# StdIn
# - None
#
#==============================================================================
# OUTPUT
#==============================================================================
# Output variables
# - None
#
# StdOut
# - Prints out the interpreted commands output.
#
# StdErr
# - Error that occured during operation.
#
# Status
# -  0 : ok
# - !0 : error
#==============================================================================
dm_cli__interpreter() {
  dm_lib__debug "dm_cli__interpreter" "interpreter starting.."
  while [ "$DM__GLOBAL__CLI__EXIT_CONDITION" = "0" ]
  do
    dm_lib__debug "dm_cli__interpreter" "waiting for user input.."
    printf "%s" "$DM__GLOBAL__CLI__PROMPT"
    read -r raw_command
    if [ -z "$raw_command" ]
    then
      dm_lib__debug "dm_cli__interpreter" \
        "empty user input received, skip processing.."
      continue
    fi

    _command="$(_dm_cli__get_command "$raw_command")"
    dm_lib__debug "dm_cli__interpreter" "executing command: '${_command}'"
    $_command
    dm_lib__debug "dm_cli__interpreter" "command '${_command}' executed"

  done
  dm_lib__debug "dm_cli__interpreter" "interpreter finished"
}

#==============================================================================
# INITIALIZATION
#==============================================================================

dm_cli__init() {
  dm_lib__debug "dm_cli__init" "initialization started"
  dm_lib__cache__init
  dm_lib__variables__load "run_formatting_in_the_backgroud"
  dm_lib__debug "dm_cli__init" "initialization finished"
}

dm_cli__welcome_message() {
  echo " ${BOLD}dotmodules${RESET} ${DIM}v${DM__GLOBAL__RUNTIME__VERSION}${RESET}"
}

#==============================================================================
# ENTRY POINT
#==============================================================================

dm_cli__welcome_message
dm_cli__init
dm_cli__interpreter
